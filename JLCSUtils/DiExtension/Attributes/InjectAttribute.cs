using JohnLambe.Util;
using JohnLambe.Util.Diagnostic;
using JohnLambe.Util.Reflection;
using JohnLambe.Util.Types;
using System;

namespace DiExtension.Attributes
{
    /// <summary>
    /// Attribute to indicate that a property may be injected, or to provide more information about how 
    /// something (including constructor parameters) is injected.
    /// <para>
    /// Injecting a field is not supported (and public fields are not recommended).
    /// </para>
    /// </summary>
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Event | AttributeTargets.Parameter | AttributeTargets.Constructor,
        AllowMultiple = false, Inherited = true)]
    //TODO: Allow on methods - to cause the method to be called with each parameter resolved similarly to a constructor parameter. ? 
    // The Key and ByType properties would not be used (so use different class with a common base class?). Throw exception if non-default values supplied?
    // If Required==false, and not all required parameters are resolved, don't call?
    public class InjectAttribute : DiAttribute
    {
        /// <summary>
        /// Value of <see cref="Key"/> or <see cref="Property"/> to indicate that the name in code of the attributed member should be used as the key.
        /// </summary>
        public const string CodeName = "<CodeName>\x00";

        //| This overload exists because code generated by Visual Studio (2015) (e.g. when generating constructors of a derived class)
        //| populates all optional parameters in attribute constructors. Omitting them is more readable them populating them with null,
        //| and populating them null results in an ambiguous parameter list (between the other overloads, where the null values could be either type).
        public InjectAttribute() : this((string)null)
        {
        }

        public InjectAttribute([Nullable] string key, [Nullable] string propertyName = null)
        {
            Key = key;
            if(key != null)         // if a key is provided
                ByType = false;     // resolving by type is not allowed by default

            if(propertyName != null)
                SetProperty(propertyName);
        }

        /// <summary>
        /// Injects a property 
        /// </summary>
        /// <param name="serviceType"><see cref="ServiceType"/></param>
        /// <param name="propertyName">The name of a property on the <paramref name="serviceType"/> instance to be injected.</param>
        public InjectAttribute([NotNull] Type serviceType, [NotNull] string propertyName)
        {
            ServiceType = serviceType.ArgNotNull(nameof(serviceType));
            SetProperty(propertyName);
        }

        protected virtual void SetProperty(string propertyName)
        {
            propertyName.ArgNotNull(nameof(propertyName), typeof(InjectAttribute).FullName + ": " + nameof(propertyName) + " cannot be null");

//            ServiceType.GetProperty(propertyName);
            Property = propertyName;
        }

        /// <summary>
        /// If false, this attribute and any other <see cref="InjectAttribute"/> attributes on the same item
        /// are ignored.
        /// This can be used to override (and disable) an attribute on the overridden member in a base class.
        /// </summary>
        //| Use of this (set to false) could arguably be considered a violation of the Liskov Substitution Principle. Maybe shouldn't be supported.
        //| The same could be said of allowing overriding at all.
        public virtual bool Enabled { get; set; } = true;

        public virtual Type ServiceType { get; }
        public virtual string Property { get; protected set; }

        /// <summary>
        /// Name/key of the value to be injected in the DI context.
        /// <para>
        /// Iff <see cref="CodeName"/>, the name of the item (property or parameter) is used.
        /// Iff null (the default), it is not resolved by key.
        /// Must not contain control codes / invisible characters except by using constants of this class.
        /// </para>
        /// </summary>
        //| The default behaviour is to resolve by type (principle of least surprise).
        //| It might be useful to make the default to resolve by the member name when the type is a primitive,
        //| but handling primitives differently could be counter-intuitive - it would be easy for a developer to
        //| think that that is the default behavior for everything.
        public virtual string Key { get; set; }

        /// <summary>
        /// True iff an exception should be thrown if the dependency cannot be resolved.
        /// </summary>
        public virtual bool Required { get; set; } = true;

        /// <summary>
        /// True iff the item should be resolved by the key (rather than just by its type).
        /// </summary>
        public virtual bool ByKey => Key != null;

        /// <summary>
        /// True if resolving by type alone is allowed.
        /// <para>
        /// If a <see cref="Key"/> is given, it overrides this.
        /// If this is true and a <see cref="Key"/> is supplied, resolving by type is done if resolving by Key fails.
        /// </para>
        /// </summary>
        public virtual bool ByType { get; set; } = true;

        /*
        /// <summary>
        /// Iff false, a different instance is used each time.
        /// </summary>
        [Obsolete("Not implemented yet")]
        public virtual bool Shared { get; set; } = true;

        /// <summary>
        /// Iff true, a clone of the instance that would otherwise be injected is injected.
        /// </summary>
        public virtual bool Clone { get; set; } = false;
        */

        public override string ToString()
        {
            return DiagnosticStringUtil.ObjectToString(this);
        }
    }

    public class InjectByNameAttribute : InjectAttribute
    {
        /// <summary>
        /// Inject the attributed item, using its name as the key.
        /// </summary>
        public InjectByNameAttribute() : base(CodeName)
        {
        }

        /// <summary>
        /// Inject the attributed item with a property of an instance of (<paramref name="serviceType"/>)
        /// from dependency injection, where the name of the property matches the name of the attributed item.
        /// </summary>
        /// <param name="serviceType"></param>
        public InjectByNameAttribute(Type serviceType) : base(serviceType, CodeName)
        {
        }
    }

}
