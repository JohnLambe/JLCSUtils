Plugin Framework and related items

From https://docs.google.com/document/d/1TyR_jZ_M4oQERqAfAvrmdq2d25NCciY8l36zBA_W4Us/edit
	Created 2016-03-13 21:30
	Last modified: 2016-03-16 00:57

Here are my unfinished ideas for a plugin framework:

I'm using .NET/C# terminology here, but this could equally be applied in Java or other languages with the necessary features.


Plugin Host

The Plugin Host should manage plugins, and facilitate communication between them only.


Plugin Assemblies

Each plugin has an optional assembly that provides interfaces that other plugins can use to interact with it.
These could be included in all deployments, whether the actual plugin is available or not.
Nothing (except assemblies specific to that plugin) should directly reference the main assembly of the plugin. This would be deployed only for installations that have licenced the plugin.

Similarly, the plugin Host would have an interface and implementation assembly.
Plugins would reference the interface one only (with interfaces and Attributes).


Dependency Injection (DI)

An abstraction of a DI container is used to decouple the DI implementation, at least from most users of it. This could be a wrapper or subclass (of the DI container of the actual DI framework) that implements the interface. (Some code may be given access to the underlying DI implementation for advanced features, leaving a limited amount that would be affected by changing the DI implementation). (That's not specific to a plugin framework.)

The Plugin Host takes a reference to a DI container. If not null, it runs DI on each plugin object it creates.
The DI container contains the container itself (for injection into factory classes) (but see Plugin Categories below).

On initialisation, the Host sends an Event (see below) to the new plugin object. The event handler can have an implementation of an interface (of the DI container abstraction) injected, that allows registering instances or mappings in the DI container.


Plugin Loading

Plugins declare their dependencies on other plugins, including required versions, and their minimum supported version of the plugin Host, using attributes (so that these can be inspected by loading the assembly for reflection) or a configuration file (XML).
Dependencies could also be inferred from references to types in the public assembly of another plugin.

Plugin classes to be initialised at startup are identified by an attribute.

The procedure for initialising plugins on starting the application is:
- Scan a directory for all relevant assemblies, chosen by a file naming convention.
- Scan all of these assemblies for plugin classes to be initialised.
- Initialise all relevant plugin classes that have their requirements.
- Repeat the previous step until none are initialised on the last iteration.
- If any remain, report a warning with the details.
In a stateful server that has an instance of this system for each client, steps 1 to 2 would only have to be done once (probably before creating any worker threads, thus creating read-only data that can efficiently be shared between threads), with the remaining steps done for each client. Each client would have its own Di context (a child of a common root one).
In a stateless server (e.g. a web application), the usual loading procedure could be used on startup, but the only classes created would be for server-wide initialisation, setting up route mappings, and caching immutable instances.

The framework could resolve the case of two objects needing to be injected with references to each other, by a two-pass dependency injection.

Plugin Containers

Implement interface:
  Implement the Composite pattern.
  They have a Unique ID.
Attributes on a Plugin class cause an instance to be added to zero or more containers on initialisation.

Option to instantiate multiple instances, potentially registered with different containers ?

Events

The Host provides an Event-sending service, in the DI container.
This has method(s) that take an Event object, a destination (Plugin Container or ID), and filter criteria (or propagation options).
The Event object implements interface and provides properties as a map or (preferably) object properties with an attribute.
The event system locates the plugin objects that should receive the event and invokes a method on them (based on an attribute), populating its parameters (with properties of the event and/or values from the DI container), according to attributes (similar to events in the Spring Framework).

The Host sends a few events, for example on initialisation of plugins, starting and shutting down the system.


Plugin Categories

A plugin object may have 0 or more categories, defined by an attribute.
Being in a certain category can cause the Host to use a different DI container for it, for example, only factory classes should have the ability to have the DI container itself injected.
It may also restrict what events it can receive, and be used for filtering event recipients.
(Categories could serve as roles or rights.)

Plugin categories will be defined by interfaces, or could possibly be string constants with heirarchical names (like paths).
(If interfaces are used, a heirarhcy is defined by interface inheritance).


Auto Factories

Interface IFactory<TInterfaceType,TParamType1,...>.
If DI container has a mapping from interface TInterfaceType to a non-abstract class, it creates a Factory<TInterfaceType,TParamType1,...> which has a property of the class type to be created.

IFactory<TInterfaceType,TParamType1,...>
{
	TInterfaceType Create(TParamType1,...);
}


Plugin Collections

Plugins could separated into collections/groups by putting their assemblies in different directories (or other means, such as a naming convention).

Different Plugin Collections could be initialised at different times. This would enable, for example, a splash screen plugin and login plugin (proving the login dialog) to be initialised and run first.


Menu

A menu could be an IPluginContainer, containing IPluginContainers for sub-menus, and IPlugins for leaf items.


In Desktop Applications

The main window could be an IPluginContainer.
It could include a status bar, or the status bar could be another PluginContainer, typically registered with the main window.
It could have containers for the top (typically for a menu, maybe with toolbar(s) below it), bottom (could be used for a status bar), each side (could be used for icon bars, toolbars, or panels that always visible, maybe with an icon to expand/contract them), and the main area (e.g. for MDI children).


Web App

Generate pages from attributes on model objects.
//Usual loading procedure, but only classes created are for server-wide initialisation, setting up route mappings, and caching immutable instances.





----------------
From WordPress blog:

Here are my unfinished ideas for a plugin framework:

(This is not language or platform specific but requires certain features available in both Java and .NET, and others).

Plugin Host

The Plugin Host should manage plugins, and facilitate communication between them only.

Plugin Assemblies

Each plugin has an optional Jar (or directory of class files) / assembly file that provides interfaces that other plugins can use to interact with it.
These could be included in all deployments, whether the actual plugin is available or not.
Nothing (except Jars / assemblies specific to that plugin) should directly reference the main Jar file / assembly of the plugin. This would be deployed only for installations that have installed the plugin.

Similarly, the plugin Host would have an interface and implementation Jar / assembly.
Plugins would reference the interface one only (with interfaces and Attributes).

Dependency Injection (DI)

An abstraction of a DI container is used to decouple the DI implementation, at least from most users of it. This could be a wrapper or subclass (of the DI container of the actual DI framework) that implements the interface. (Some code may be given access to the underlying DI implementation for advanced features, leaving a limited amount that would be affected by changing the DI implementation). (That's not specific to a plugin framework.)



The Plugin Host takes a reference to a DI container. If not null, it runs DI on each plugin object it creates.
The DI container contains the container itself (for injection into factory classes) (but see Plugin Categories below).

On initialisation, the Host sends an Event (see below) to the new plugin object. The event handler can have an implementation of an interface (of the DI container abstraction) injected, that allows registering instances or mappings in the DI container.

An extension of the DI framework could enable objects created by framework to be injected with a reference to the object that they are being injected into (when a new instance is created for each). The Event sender service (mentioned later) would use this to get a reference to the plugin it is injected into so that the framework knows which plugin is sending the event.

Plugin Loading

Plugins declare their dependencies on other plugins, including required versions, and their minimum supported version of the plugin Host, using annotations / attributes (in .NET, these can be inspected by loading the assembly for reflection) or a configuration file (XML).
Dependencies could also be inferred from references to types in the public Jar / assembly of another plugin.

Plugin classes to be initialised (and maybe static methods to be called) at startup are identified by an annotation / attribute.

The procedure for initialising plugins on starting the application is:
- Scan a directory for all relevant Jars / assemblies, chosen by a file naming convention.
- Scan all of these Jars / assemblies for plugin classes to be initialised. (In Java, the Jar file could be opened as a Zip file to read the classes).
- Initialise all relevant plugin classes that have their requirements.
- Repeat the previous step until none are initialised on the last iteration.
- If any remain, report a warning with the details.
In a stateful server that has an instance of this system for each client, steps 1 to 2 would only have to be done once (probably before creating any worker threads, thus creating read-only data that can efficiently be shared between threads), with the remaining steps done for each client. Each client would have its own Di context (a child of a common root one).
In a stateless server (e.g. a web application), the usual loading procedure could be used on startup, but the only classes created would be for server-wide initialisation, setting up route mappings, and caching immutable instances.

The framework could resolve the case of two objects needing to be injected with references to each other by setter or method injection, by a two-pass dependency injection.

Plugin Containers

A Plugin Container is a plugin which can have other plugins registered with it as children.
(A container can be used as a collection of event handlers (see below).)

Implement interface:
- Implement the Composite pattern.
- They have a Unique ID.
Annotations / attributes on a Plugin class cause an instance to be added to zero or more containers on initialisation (an optional priority can be supplied, which determines the order in which the plugins are sorted within the container (which is also the order in which events are delivered to them)).

Maybe an option to instantiate multiple instances, potentially registered with different containers ?

Option for only the container owner to be able to send events to it?

Optionally define the events that are valid for sending to a container, on the container (by annotations / attributes) ?

Should it be possible to enumerate plugins in a container, and query each one for an interface ?

Events

The Host provides an Event-sending service, in the DI container.
This has method(s) that take an Event object, a destination (Plugin Container or ID), and filter criteria (or propagation options).
The Event object implements an interface and provides properties as a map or (preferably) object properties with an annotation / attribute.
The event system locates the plugin objects that should receive the event and invokes a method on them (based on an annotation / attribute), populating its parameters (with properties of the event and/or values from the DI container), according to annotations / attributes (similar to events in the Spring Framework).

An object with details of the event sender could be available for injection. But that might encourage tight coupling.

The Host sends a few events, for example on initialisation of plugins, starting and shutting down the system.

Plugin Categories

A plugin object may have 0 or more categories, defined by an annotation / attribute.
Being in a certain category can cause the Host to use a different DI container for it, for example, only factory classes should have the ability to have the DI container itself injected.
It may also restrict what events it can receive, and be used for filtering event recipients.
(Categories could serve as roles or rights.)

Plugin categories will be defined by interfaces, or could possibly be string constants with hierarchical names (like paths).
(If interfaces are used, a hierarchy is defined by interface inheritance).

Plugin Collections

Plugins could separated into collections/groups by putting their Jars / assemblies in different directories (or other means, such as a naming convention).

Different Plugin Collections could be initialised at different times. This would enable, for example, a splash screen plugin and login plugin (proving the login dialog) to be initialised and run first.



Some Uses



Menu

A menu could be an IPluginContainer, containing IPluginContainers for sub-menus, and IPlugins for leaf items.

In Desktop Applications

The main window could be an IPluginContainer.
It could include a status bar, or the status bar could be another PluginContainer, typically registered with the main window.
It could have containers for the top (typically for a menu, maybe with toolbar(s) below it), bottom (could be used for a status bar), each side (could be used for icon bars, toolbars, or panels that always visible, maybe with an icon to expand/contract them), and the main area (e.g. for MDI children).


------
Container interfaces with method for sending events to the container:
  Annotate/attribute method, and framework generates dynamic (generated code in Java; using Impromptu Interface in .NET) object that implements it.

Tool (to run on build) to statically validate event handlers.

Container Interface
Annotations / attributes on Containers (on interface) can specify events that 

Annotation / attribute on event parameters (property/getter/setter in interface that defines the event) can specify that they are required to be passed to all handlers (i.e. handler is rejected if it does not accept them).

Goals:

- To facilitate breaking an application into loosely-coupled modules, such that modules can be installed and removed from individual installations.
  Where modules have dependencies on other modules, these are declared, so that the framework can identify modules that don't have their requirement, report them to the user and not load those modules.
- Automatically assigning dependencies (declared in the code) between loosely-coupled objects within these modules (both between objects of the same module and different ones).

