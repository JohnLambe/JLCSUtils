DiExtension Publish-Subscribe Injection (Draft)

V.1.1:

INTERFACE:


Publisher:
	[Publisher]
	public IMessageSender Broker { get; set; }
	

Subscriber:

	public AnySubscriber : ISubscriber
	{
		[Subscriber(MessageType = typeof(IMessage))]  // MessageType would default to parameter type. Redundant in this example.
		public void ReceiveMessage(IMessage message);
			// Later version: Spring-like parameter injection (declare parameters for message object and/or just the properties required).
			// Parameter to identify the publisher?? Details could be inlcuded in message if necessary.
		
		event ISubscriber.Unsubscribe;
	}

	public interface IMessageSender<TMessage>
	{
		void Send(TMessage message);
	}
	
	
IMPLEMENTATION:

Message Broker:
	DI singleton.
	
	public class MessageBroker
	{
		public void Send(object Message);
			// Parameter to identify sender??
			// Implementation (from caller's perspective) may be asynchronous or synchronous. Initial implementation will be synchronous.
		
		public {SubscriberHandle} RegisterSubscriber( Subscriber subscriber );
			
		// Could have overloads with parameters convertible to Subscriber, e.g.
		public void RegisterSubscriber<T>( Action<T> deliver );   // T is Subscribe.MessageType; no Filter.
		
		
		public void DeregisterSubscriber({SubscriberHandle});
		
		protected Subscriber Subscribers;
		
		// {SubscriberHandle} is an opaque object to the consumer of MessageBroker.
		// It could be `object` and be implemented by returning Subscriber.
		// It could be a nested class not visible outside MessageBroker, or internal to its assembly.
		// The `subscriber` parameter to RegisterSubscriber could be of a subclass of the type held in `Subscribers`. The latter, and {SubscriberHandle} could be non-visible outside MessageBroker (or its assembly).
		// Alternatively, the consumer could provide an ID on registration (RegisterSubscriber would not return anything), that it uses on deregistration. Subscriber could hold it in an ID property.
		//   But an ID seems unnecessary, and this {SubscriberHandle} is probably just as convenient for the consumer (or more convenient since it doesn't have to create it).
		//   Alternative 2: The consumer could provide any object as a handle. Hence, it could be the consuming class itself (which doesn't have to implement any defined interface).
		
		// When the handle is `Subscriber`, this could hold weak references to it, so that consumer doesn't have to deregister?
		// In the DI system, the DI extension would have to hold the handle or embed it in a delegate added to the 'unsubscribe' event.
	}
	
	class Subscriber
	{
	    /// <summary>Type of message handled. The delegates in this class must not be called with messages that are not of this type.</summary>
		public Type MessageType;
		public Func<object,bool> Filter;   // pass message; returns true if it should be delivered. Always deliver if this is null and message is correct type.
		public Action<object> Deliver;     // deliver the message. Must be of type MessageType.
	}
		

Publisher:
	On BuildUp:
		Create and inject IMessageSender.
		
	MessageSender delegates to MessageBroker.
	MessageSender is not IDisposable.

Subscriber:
	On BuildUp:
		Call MessageBroker.RegisterSubscriber for each handler method.
		The subscriber must implement ISubscriber or INotifyOnDispose. (The latter is not used if the former is implemented).
				Could also use a 'Disposed' event even if interface is not implemented.
		Attach handler to event fired to unsubscribe (Unsubscribe/Disposed) (handler calls MessageBroker.DeregisterSubscriber).
	
	
ALTERNATIVES:
	Subscriber method could use the same attributes as for auto-wired event handlers.

